{"version":3,"file":"index.js","sources":["../src/utils/constants.ts","../src/components/core/MantleProvider/MantleProvider.tsx","../src/utils/features.ts","../src/utils/money.ts","../src/utils/plans.ts","../src/utils/views.ts"],"sourcesContent":["export const PlanAvailability = {\n  Public: \"public\",\n  CustomerTag: \"customerTag\",\n  ShopifyPlan: \"shopifyPlan\",\n  Customer: \"customer\",\n  Hidden: \"hidden\",\n} as const;\n\nexport const Labels = {\n  AmountPerInterval: \"{{ amount }} per {{ interval }}\",\n  Back: \"Back\",\n  Cancel: \"Cancel\",\n  CancelConfirmation: \"Are you sure you want to cancel your subscription?\",\n  CancelPlan: \"Cancel plan\",\n  ChangePlan: \"Change plan\",\n  CurrentPlan: \"Current plan\",\n  CustomPlans: \"Custom plans\",\n  CustomPlansDescription: \"Plans tailored to your specific needs\",\n  DiscountAmount: \"{{ amount }} discount\",\n  DiscountAmountExpired: \"{{ amount }} discount expired\",\n  FreeTrialLength: \"{{ trialDays }}-day free trial\",\n  Features: \"Features\",\n  Month: \"month\",\n  MonthShort: \"mo\",\n  Monthly: \"Monthly\",\n  NextBillingDate: \"Next billing date\",\n  NotSubscribed: \"You're not subscribed to a plan yet.\",\n  Year: \"year\",\n  YearShort: \"yr\",\n  Yearly: \"Yearly\",\n  MostPopular: \"Most popular\",\n  Per: \"/\",\n  Plans: \"Plans\",\n  Price: \"Price\",\n  SelectPlan: \"Select plan\",\n  SubscribeSuccessTitle: \"Subscription successful\",\n  SubscribeSuccessBody: \"Thanks for subscribing to our app!\",\n  Subscription: \"Subscription\",\n  SubscriptionCancelled: \"Subscription cancelled\",\n  UsageCharges: \"Usage charges\",\n\n  // Common\n  loading: \"Loading...\",\n  error: \"An error occurred\",\n  retry: \"Retry\",\n  cancel: \"Cancel\",\n  continue: \"Continue\",\n  \n  // Subscription\n  subscribe: \"Subscribe\",\n  subscribeNow: \"Subscribe Now\",\n  upgradeNow: \"Upgrade Now\",\n  manageSubscription: \"Manage Subscription\",\n  cancelSubscription: \"Cancel Subscription\",\n  \n  // Payment\n  addPaymentMethod: \"Add Payment Method\",\n  updatePaymentMethod: \"Update Payment Method\",\n  \n  // Features\n  featureNotAvailable: \"This feature is not available on your current plan\",\n  upgradeRequired: \"Upgrade Required\",\n  limitReached: \"Limit Reached\",\n} as const;\n","import type {\n  Customer,\n  Feature,\n  HostedSession,\n  Notify,\n  Plan,\n  RequirePaymentMethodOptions,\n  SetupIntent,\n  Subscription,\n  UsageEvent,\n} from \"@heymantle/client\";\nimport { MantleClient } from \"@heymantle/client\";\nimport React, { createContext, useContext, useEffect, useState } from \"react\";\nimport { Labels } from \"../../../utils/constants\";\n\n/** The main context interface that encapsulates functionality exposed by MantleProvider */\nexport interface TMantleContext {\n  /** The MantleClient instance */\n  client: MantleClient;\n  /** The current customer */\n  customer: Customer | null;\n  /** The current subscription */\n  subscription: Subscription | null;\n  /** The available plans */\n  plans: Plan[];\n  /** Whether the current customer is loading */\n  loading: boolean;\n  /** Internationalization labels */\n  i18n: typeof Labels;\n  /** Refetch the current customer */\n  refetch: () => Promise<void>;\n  /** Send a new usage event to Mantle */\n  sendUsageEvent: SendUsageEventCallback;\n  /** Get a usage report for a usage metric */\n  getUsageReport: GetUsageReportCallback;\n  /** Subscribe to a new plan */\n  subscribe: SubscribeCallback;\n  /** Cancel the current subscription */\n  cancelSubscription: CancelSubscriptionCallback;\n  /** Start the process of adding a new payment method */\n  addPaymentMethod: AddPaymentMethodCallback;\n  /** Check if a feature is enabled */\n  isFeatureEnabled: FeatureEnabledCallback;\n  /** Get the limit for a feature */\n  limitForFeature: FeatureLimitCallback;\n  /** Create a hosted session */\n  createHostedSession: HostedSessionCallback;\n  /** Send a notification */\n  notify: NotifyCallback;\n  /** Get a notifications */\n  listNotifies: ListNotifiesCallback;\n}\n\n/** Callback to send a new usage event to Mantle */\nexport type SendUsageEventCallback = (usageEvent: UsageEvent) => Promise<void>;\n\n/** Callback to get a usage report for a usage metric */\nexport type GetUsageReportCallback = (params: {\n  /** The ID of the usage metric to get a report for */\n  usageId: string;\n  /** The period to get the usage report for */\n  period: string;\n}) => Promise<any>;\n\n/** Common subscription parameters without the plan selection */\nexport type BaseSubscribeParams = {\n  /** The ID of the discount to apply */\n  discountId?: string;\n  /** The billing provider to use */\n  billingProvider?: string;\n  /** The URL to return to after subscribing */\n  returnUrl?: string;\n  /** Whether to use the saved payment method for the customer. Defaults to true. */\n  useSavedPaymentMethod?: boolean;\n  /** The number of trial days to offer */\n  trialDays?: number;\n  /** (Stripe only) Whether to use Stripe checkout for the subscription. Not applicable for Shopify subscriptions as they are always hosted */\n  hosted?: boolean;\n  /** (Stripe only) The collection method to use for the subscription */\n  collectionMethod?: string;\n  /** (Stripe only) The number of days until the subscription is due */\n  daysUntilDue?: number;\n  /** (Stripe only) The payment method types to use for the subscription */\n  paymentMethodTypes?: string[];\n  /** (Stripe only) When to require a payment method for the subscription */\n  requirePaymentMethod?: RequirePaymentMethodOptions;\n  /** (Stripe only) Whether to automatically calculate tax for the subscription. Defaults to false. */\n  automaticTax?: boolean;\n  /** (Stripe checkout only) Tell the Stripe Checkout Session to require a billing address */\n  requireBillingAddress?: boolean;\n  /** (Stripe checkout only) Prefill the Stripe customer's email address */\n  email?: string;\n  /** (Stripe checkout only) Key-value pairs of metadata to attach to the subscription */\n  metadata?: Record<string, string>;\n};\n\n/** Parameters for subscribing to a single plan */\nexport type SinglePlanSubscribe = BaseSubscribeParams & {\n  /** The ID of the plan to subscribe to */\n  planId: string;\n  /** Not allowed when using planId */\n  planIds?: never;\n};\n\n/** Parameters for subscribing to multiple plans */\nexport type MultiPlanSubscribe = BaseSubscribeParams & {\n  /** Not allowed when using planIds */\n  planId?: never;\n  /** The IDs of the plans to subscribe to */\n  planIds: string[];\n};\n\n/** Callback to subscribe to a new plan or plans */\nexport type SubscribeCallback = (\n  params: SinglePlanSubscribe | MultiPlanSubscribe\n) => Promise<Subscription>;\n\n/** Callback to cancel the current subscription */\nexport type CancelSubscriptionCallback = (params?: {\n  /** The reason for canceling the subscription */\n  cancelReason?: string;\n}) => Promise<Subscription>;\n\n/** Callback to start the process of adding a new payment method */\nexport type AddPaymentMethodCallback = (params: {\n  /** The URL to return to after connecting a new PaymentMethod */\n  returnUrl: string;\n}) => Promise<SetupIntent>;\n\n/** Callback to check if a feature is enabled */\nexport type FeatureEnabledCallback = (params: {\n  /** The key of the feature to evaluate */\n  featureKey: string;\n  /** The count to evaluate against the feature limit if there is one */\n  count?: number;\n}) => boolean;\n\n/** Callback to get the limit for a feature */\nexport type FeatureLimitCallback = (params: {\n  /** The key of the feature to evaluate */\n  featureKey: string;\n}) => number;\n\n/** Callback to create a hosted session */\nexport type HostedSessionCallback = (params: {\n  /** The type of hosted session to create */\n  type: string;\n  /** The configuration for the hosted session */\n  config: Record<string, any>;\n}) => Promise<HostedSession>;\n\nexport type ListNotifiesCallback = () => Promise<{\n  notifies: Notify[];\n  hasMore: boolean;\n}>;\n\n/** Callback to send a notification */\nexport type NotifyCallback = (params: {\n  templateId: string;\n}) => Promise<string[]>;\n\n/** Callback to list notifications */\nexport type ListNotificationsCallback = () => Promise<Notification[]>;\n\n/** Props for the MantleProvider component */\nexport interface MantleProviderProps {\n  /** The Mantle App ID provided by Mantle */\n  appId: string;\n  /** The Mantle Customer API Token returned by the identify endpoint */\n  customerApiToken: string;\n  /** The Mantle API URL to use */\n  apiUrl?: string;\n  /** The children to render */\n  children: React.ReactNode;\n  /** The i18n object to use for labels */\n  i18n?: typeof Labels;\n  /** Whether to wait for the customer to be fetched */\n  waitForCustomer?: boolean;\n  /** The component to render while waiting for the customer to be fetched */\n  loadingComponent?: React.ReactNode;\n}\n\n/** React Context for providing Mantle functionality throughout the app */\nconst MantleContext = createContext<TMantleContext | undefined>(undefined);\n\n/**\n * Evaluates whether a feature is enabled based on its type and value\n * @param feature - The feature to evaluate\n * @param count - The count to evaluate against if the feature is a limit type\n * @returns Whether the feature is considered enabled\n */\nconst evaluateFeature = ({\n  feature,\n  count = 0,\n}: {\n  feature: Feature;\n  count?: number;\n}): boolean => {\n  if (feature?.type === \"boolean\") {\n    return feature.value;\n  } else if (feature?.type === \"limit\") {\n    return count < feature.value || feature.value === -1;\n  }\n  return false;\n};\n\n/**\n * MantleProvider uses the React Context API to provide a MantleClient instance and\n * the current customer to its children, which can be accessed using the useMantle hook.\n *\n * @example\n * ```tsx\n * function App() {\n *   return (\n *     <MantleProvider\n *       appId=\"your-app-id\"\n *       customerApiToken=\"customer-token\"\n *     >\n *       <YourApp />\n *     </MantleProvider>\n *   );\n * }\n * ```\n */\nexport const MantleProvider: React.FC<MantleProviderProps> = ({\n  appId,\n  customerApiToken,\n  apiUrl = \"https://appapi.heymantle.com/v1\",\n  children,\n  i18n = Labels,\n  waitForCustomer = false,\n  loadingComponent = null,\n}) => {\n  const mantleClient = new MantleClient({ appId, customerApiToken, apiUrl });\n  const [customer, setCustomer] = useState<Customer | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  /**\n   * Fetches the current customer from Mantle's API\n   * Updates the customer state and handles loading states\n   */\n  const fetchCustomer = async () => {\n    try {\n      setLoading(true);\n      const customer = await mantleClient.getCustomer();\n      setCustomer(customer);\n    } catch (error) {\n      console.error(\"[MantleProvider] Error fetching customer: \", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  /**\n   * Sends a usage event to Mantle\n   * @param usageEvent - The usage event to send\n   */\n  const sendUsageEvent: SendUsageEventCallback = async (usageEvent) => {\n    await mantleClient.sendUsageEvent(usageEvent);\n  };\n\n  /**\n   * Gets a usage report for a specific metric and period\n   * @param params.usageId - The ID of the usage metric\n   * @param params.period - The period to get the report for\n   * @returns The usage report data\n   */\n  const getUsageReport: GetUsageReportCallback = async ({\n    usageId,\n    period,\n  }) => {\n    return await mantleClient.getUsageMetricReport({ id: usageId, period });\n  };\n\n  /**\n   * Subscribes to one or more plans\n   * @param params - Either SinglePlanSubscribe or MultiPlanSubscribe parameters\n   * @returns The created subscription\n   */\n  const subscribe: SubscribeCallback = async (params) => {\n    return await mantleClient.subscribe(params);\n  };\n\n  /**\n   * Cancels the current subscription\n   * @param params.cancelReason - Optional reason for cancellation\n   * @returns The cancelled subscription\n   */\n  const cancelSubscription: CancelSubscriptionCallback = async ({\n    cancelReason,\n  } = {}) => {\n    return await mantleClient.cancelSubscription({\n      ...(cancelReason && { cancelReason }),\n    });\n  };\n\n  /**\n   * Initiates the process of adding a new payment method\n   * @param params.returnUrl - The URL to return to after adding the payment method\n   * @returns A SetupIntent for completing the payment method addition\n   * @throws Error if returnUrl is not provided\n   */\n  const addPaymentMethod: AddPaymentMethodCallback = async ({ returnUrl }) => {\n    if (!returnUrl) {\n      throw new Error(\"returnUrl is required\");\n    }\n    return await mantleClient.addPaymentMethod({ returnUrl });\n  };\n\n  /**\n   * Creates a hosted session for various checkout flows\n   * @param params.type - The type of hosted session to create\n   * @param params.config - Configuration options for the hosted session\n   * @returns The created hosted session\n   * @throws Error if type is not provided\n   */\n  const createHostedSession: HostedSessionCallback = async ({\n    type,\n    config,\n  }) => {\n    if (!type) {\n      throw new Error(\"type is required\");\n    }\n    const searchParams = new URL(document.location.toString()).searchParams;\n    const locale = searchParams.get(\"locale\");\n    return await mantleClient.createHostedSession({\n      type,\n      config: {\n        ...(locale ? { locale } : {}),\n        ...(config || {}),\n      },\n    });\n  };\n\n  const notify: NotifyCallback = async ({ templateId }) => {\n    return await mantleClient.notify({ templateId });\n  };\n\n  const listNotifies: ListNotifiesCallback = async () => {\n    return await mantleClient.listNotifies();\n  };\n\n  // Fetch customer when the token changes\n  useEffect(() => {\n    if (customerApiToken) {\n      fetchCustomer();\n    }\n  }, [customerApiToken]);\n\n  const plans = customer?.plans || [];\n  const subscription = customer?.subscription || null;\n\n  if (waitForCustomer && loading) {\n    return loadingComponent || null;\n  }\n\n  return (\n    <MantleContext.Provider\n      value={{\n        client: mantleClient,\n        customer,\n        subscription,\n        plans,\n        loading,\n        i18n: { ...Labels, ...i18n },\n        sendUsageEvent,\n        getUsageReport,\n        subscribe,\n        cancelSubscription,\n        addPaymentMethod,\n        createHostedSession,\n        notify,\n        listNotifies,\n        isFeatureEnabled: ({ featureKey, count = 0 }) => {\n          if (customer?.features[featureKey]) {\n            return evaluateFeature({\n              feature: customer.features[featureKey],\n              count,\n            });\n          }\n          return false;\n        },\n        limitForFeature: ({ featureKey }) => {\n          if (\n            customer?.features[featureKey] &&\n            customer.features[featureKey].type === \"limit\"\n          ) {\n            return customer.features[featureKey].value;\n          }\n          return -1;\n        },\n        refetch: async () => {\n          await fetchCustomer();\n        },\n      }}\n    >\n      {children}\n    </MantleContext.Provider>\n  );\n};\n\n/**\n * React hook to access the Mantle context\n * Must be used within a MantleProvider component\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const { customer, subscription } = useMantle();\n *   return <div>Hello {customer?.name}</div>;\n * }\n * ```\n *\n * @returns The Mantle context containing all Mantle functionality\n * @throws Error if used outside of a MantleProvider\n */\nexport const useMantle = (): TMantleContext => {\n  const context = useContext(MantleContext);\n\n  if (context === undefined) {\n    throw new Error(\"useMantle must be used within a MantleProvider\");\n  }\n\n  return context;\n};\n","import type { Feature } from '@heymantle/client';\n\n/**\n * Determines if a feature is enabled based on its type and value\n * @param feature - The feature to check\n * @returns true if the feature is enabled\n */\nexport const featureEnabled = (feature: Feature): boolean => {\n  return (\n    (feature.type === \"boolean\" && feature.value === true) ||\n    (feature.type === \"limit\" && feature.value !== 0)\n  );\n};\n\n/**\n * Sorts features by enabled status (enabled first) and then by name\n * @param a - First feature to compare\n * @param b - Second feature to compare\n * @returns Sort order (-1, 0, or 1)\n */\nexport const featureSort = (a: Feature, b: Feature): number =>\n  (Number(featureEnabled(b)) - Number(featureEnabled(a))) || a.name.localeCompare(b.name); ","/**\n * Creates a number formatter for the specified currency\n * @param currencyCode - The currency code to format for\n * @returns An Intl.NumberFormat instance configured for the currency\n */\nconst moneyFormatter = (currencyCode: string = \"USD\"): Intl.NumberFormat =>\n  new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: currencyCode,\n    notation: \"standard\",\n  });\n\n/**\n * Formats the given amount of money based on the specified currency code\n * @param amount - The amount of money to format\n * @param currencyCode - The currency code to use for formatting\n * @param removeCents - Whether to remove the cents from the formatted result\n * @returns The formatted money string\n * \n * @example\n * ```ts\n * money(1234.56) // \"$1,234.56\"\n * money(1234.56, \"USD\", true) // \"$1,234\"\n * money(1234.56, \"EUR\") // \"â‚¬1,234.56\"\n * ```\n */\nexport const money = (\n  amount: number,\n  currencyCode: string = \"USD\",\n  removeCents: boolean = true\n): string => {\n  let result = moneyFormatter(currencyCode).format(amount);\n  if (removeCents) {\n    result = result.replace(/\\.00$/, '');\n  }\n  return result;\n}; ","import type { Discount, Plan } from \"@heymantle/client\";\nimport { Labels } from \"./constants\";\n\nexport enum PlanInterval {\n  Annual = \"ANNUAL\",\n  Every30Days = \"EVERY_30_DAYS\",\n}\n\ntype IntervalLabelType = \"year\" | \"month\";\ntype IntervalLabelShortType = \"yr\" | \"mo\";\n\n/**\n * Generate a long label for the given interval\n * @param interval - The interval to generate a label for\n * @returns The long label for the interval\n */\nexport const intervalLabelLong = (interval: PlanInterval = PlanInterval.Every30Days): IntervalLabelType => {\n  switch (interval) {\n    case PlanInterval.Annual:\n      return \"year\";\n    case PlanInterval.Every30Days:\n    default:\n      return \"month\";\n  }\n};\n\n/**\n * Generate a short label for the given interval\n * @param interval - The interval to generate a label for\n * @returns The short label for the interval\n */\nexport const intervalLabelShort = (interval: PlanInterval = PlanInterval.Every30Days): IntervalLabelShortType => {\n  switch (interval) {\n    case PlanInterval.Annual:\n      return \"yr\";\n    case PlanInterval.Every30Days:\n    default:\n      return \"mo\";\n  }\n};\n\ninterface IntervalLabelParams {\n  interval?: PlanInterval;\n  useShortFormPlanIntervals?: boolean;\n}\n\n/**\n * Generate a label for the given interval and format\n * @param params.interval - The interval to generate a label for\n * @param params.useShortFormPlanIntervals - Whether to use short form plan intervals\n * @returns The label for the interval\n */\nexport const intervalLabel = ({\n  interval = PlanInterval.Every30Days,\n  useShortFormPlanIntervals = true,\n}: IntervalLabelParams): IntervalLabelType | IntervalLabelShortType => {\n  return useShortFormPlanIntervals ? intervalLabelShort(interval) : intervalLabelLong(interval);\n};\n\ninterface PlanParams {\n  plan: Plan;\n  customFieldKey?: string;\n}\n\n/**\n * Check if the plan is recommended by using custom fields\n * @param params.plan - The Mantle plan to check\n * @param params.customFieldKey - The key to check for the recommended status\n * @returns Whether the plan is recommended\n */\nexport const isRecommendedPlan = ({ \n  plan, \n  customFieldKey = \"recommended\" \n}: PlanParams): boolean => {\n  return !!plan.customFields?.[customFieldKey];\n};\n\n/**\n * Get the custom button label for the plan, or the default label\n * @param params.plan - The Mantle plan to check\n * @param params.customFieldKey - The key to check for the button label\n * @returns The custom button label or the default label\n */\nexport const customButtonLabel = ({ \n  plan, \n  customFieldKey = \"buttonLabel\" \n}: PlanParams): string => {\n  return plan.customFields?.[customFieldKey] || Labels.subscribe;\n};\n\n/**\n * Get the best discount for the plan\n * @param params.plan - The Mantle plan to check for a discount\n * @returns The highest discount for the plan, or undefined if none found\n */\nexport const highestDiscount = ({ plan }: { plan: Plan }): Discount | undefined => {\n  return plan.discounts?.length > 0\n    ? plan.discounts.reduce((prev, current) =>\n        prev.discountedAmount < current.discountedAmount ? prev : current\n      )\n    : undefined;\n}; ","interface ColumnSpans {\n  xs: number;\n  sm: number;\n  md: number;\n  lg: number;\n  xl: number;\n}\n\n/**\n * Get the column span for the grid layout\n * @param count - The number of columns\n * @returns The column span for each screen size\n * \n * @example\n * ```ts\n * columnSpan(4) // { xs: 6, sm: 6, md: 2, lg: 3, xl: 3 }\n * columnSpan(3) // { xs: 6, sm: 6, md: 2, lg: 4, xl: 4 }\n * ```\n */\nexport const columnSpan = (count: number = 4): ColumnSpans => {\n  if (count % 4 === 0) return { xs: 6, sm: 6, md: 2, lg: 3, xl: 3 };\n  if (count % 3 === 0) return { xs: 6, sm: 6, md: 2, lg: 4, xl: 4 };\n  if (count % 2 === 0) return { xs: 6, sm: 6, md: 3, lg: 6, xl: 6 };\n  if (count === 1) return { xs: 6, sm: 6, md: 6, lg: 12, xl: 12 };\n  return { xs: 6, sm: 6, md: 2, lg: 4, xl: 4 };\n};\n\n/**\n * Get the column count for the grid layout\n * @param size - The number of items\n * @returns The number of columns\n * \n * @example\n * ```ts\n * columnCount(4) // 4\n * columnCount(3) // 3\n * columnCount(2) // 2\n * ```\n */\nexport const columnCount = (size: number = 4): number => {\n  if (size % 4 === 0) return 4;\n  if (size % 3 === 0) return 3;\n  if (size % 2 === 0) return 2;\n  if (size === 1) return 1;\n  return 4;\n}; "],"names":["PlanAvailability","Labels","MantleContext","createContext","evaluateFeature","feature","count","MantleProvider","appId","customerApiToken","apiUrl","children","i18n","waitForCustomer","loadingComponent","mantleClient","MantleClient","customer","setCustomer","useState","loading","setLoading","fetchCustomer","error","sendUsageEvent","usageEvent","getUsageReport","usageId","period","subscribe","params","cancelSubscription","cancelReason","addPaymentMethod","returnUrl","createHostedSession","type","config","locale","notify","templateId","listNotifies","useEffect","plans","subscription","jsx","featureKey","useMantle","context","useContext","featureEnabled","featureSort","a","b","moneyFormatter","currencyCode","money","amount","removeCents","result","PlanInterval","intervalLabelLong","interval","intervalLabelShort","intervalLabel","useShortFormPlanIntervals","isRecommendedPlan","plan","customFieldKey","_a","customButtonLabel","highestDiscount","prev","current","columnSpan","columnCount","size"],"mappings":"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"}